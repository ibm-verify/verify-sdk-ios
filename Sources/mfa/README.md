# IBM Verify MFA SDK for iOS

The MFA software development kit (SDK) enables applications to register authenticators and enroll into the associated factors.


## Example
An [example](../../Examples/mfa) application is available for the MFA SDK

## Getting started

### Installation

[Swift Package Manager](https://swift.org/package-manager/) is used for automating the distribution of Swift code and is integrated into the `swift` compiler.  To depend on one or more of the components, you need to declare a dependency in your `Package.swift`:

```swift
dependencies: [
    .package(name: "IBM Verify", url: "https://github.com/ibm-verify/verify-sdk-ios.git", from: "3.0.12")
]
```

then in the `targets` section of the application/library, add one or more components to your `dependencies`, for example:

```swift
// Target for Swift 6.0
.target(name: "MyExampleApp", dependencies: [
    .product(name: "MFA", package: "IBM Verify")
],
```

Alternatively, you can add the package manually.
1. Select your application project in the **Project Navigator** to display the configuration window.
2. Select your application project under the **PROJECT** heading
3. Select the **Swift Packages** tab.
4. Click on the `+` button.
5. Enter `https://github.com/ibm-verify/verify-sdk-ios.git` as the respository URL and follow the remaining steps selecting the components to add to your project.

### API documentation
The MFA SDK API can be reviewed [here](https://ibm-verify.github.io/ios/documentation/mfa/).

### Importing the SDK

Add the following import statement to the `.swift` files you want to reference the MFA SDK.

```swift
import MFA
```

## Usage

### Register a multi-factor authenticator

To register an authenticator, first obtain the JSON string value from the QR code generated by IBM Verify or IBM Verify Access.

```swift
let controller = MFARegistrationController(json: qrScanResult)

// Initiate the registration provider.
let provider = try await controller.initiate(with: "John Doe", pushToken: "abc123")

// Enroll user presence if available, auto-generate keypairs.
if provider.canEnrollUserPresence {
   try await provider.enrollUserPresence()
}

if provider.canEnrollBiometric {
   // Enroll the factor. Handle the persistance of the private key using a closure.
   try await provider.enrollBiometric(
      savePrivateKey: { key in
         // Generate a unique label for the key
         let keyLabel = "private_key_for_biometric"

         // Store the key in the Keychain
         try KeychainService.shared.addItem(
            keyLabel,
            value: key,
            allowSync: false,
            accessControl: .userPresence,      // Allow device PIN fallback.
            accessibility: .afterFirstUnlock
         )

         return keyLabel
      },
      context: LAContext(),
      reason: "Verify with biometrics"
   )
}

// Complete the registration and save authenticator.
let authenticator = try await provider.finalize()
let data = try JSONEncoder().encode(authenticator)
try data.write(to: "fileLocation")
```

The private key saved to the Keychain can be accessed using the keyName provided during the enrollment.  For example:
```
guard let privateKeyData = try? KeychainService.default.readItem("private_key_for_biometric", searchType: .key),
    let privateKey = try RSA.Signing.PrivateKey(derRepresentation: privateKeyData) else {
    // No item found
    return
}
```

### Check for a transaction

Checking for a transaction requires an instance of the `MFAAuthenticatorService`.  The service maintains the current pending transaction therefore the instance must be retained between calls to `nextTransaction` and `completeTransaction`.

This example demonostrates how to check for a transaction:

```swift
// Create the controller and initiate the service.
let controller = MFAServiceController(using: authenticator)
let service = controller.initiate()

let transaction = try await service.nextTransaction(with: nil)
print(transaction)
```

### Approve or deny a transaction

Continuing the previous code snippet, the following example demonstrates how to deny or approve a transaction:

```swift
// Deny
if let factorType = authenticator.enrolledFactors.first(where: {$0.id == transaction.factorId } {
   do {
      try await self.service.completeTransaction(action: .deny, factor: factorType)
   }
   catch let error {
      print(error)
   }  
}

// Approve
if let factorType = authenticator.enrolledFactors.first(where: {$0.name == transaction.keyName } {
   do {
      try await self.service.completeTransaction(factor: factorType)
   }
   catch let error {
      print(error)
   }  
}
```

## License
This package contains code licensed under the MIT License (the "License"). You may view the License in the [LICENSE](../../LICENSE) file within this package.
