//
// Copyright contributors to the IBM Verify MFA SDK for iOS project
//

import Foundation
import Core
import Authentication

// MARK: Protocols

/// An inerface that defines a multi-factor authentication service operations.
public protocol MFAServiceDescriptor: Actor {
    /// The access token generated by the authorization server.
    var accessToken: String { get }
    
    /// The location of the endpoint to refresh the OAuth token for the authenticator.
    var refreshUri: URL { get }

    /// The location of the endpoint to perform transaction validation.
    var transactionUri: URL { get }
    
    /// The current pending transaction.
    var currentPendingTransaction: PendingTransactionInfo? { get }
    
    /// Refresh the OAuth token associated with the registered authenticator.
    /// - Parameters:
    ///   - refreshToken: The refresh token of the existing authenticator registration.
    ///   - accountName: The account name associated with the service.
    ///   - pushToken: A token that identifies the device to Apple Push Notification Service (APNS).
    ///   - additionalData: (Optional) A collection of options associated with the service.
    /// - Returns: A new `TokenInfo` for the authenticator.
    ///
    /// Communicate with Apple Push Notification service (APNs) and receive a unique device token that identifies your app.  Refer to [Registering Your App with APNs](https://developer.apple.com/documentation/usernotifications/registering_your_app_with_apns).
    func refreshToken(using refreshToken: String, accountName: String?, pushToken: String?, additionalData: [String: Any]?) async throws -> TokenInfo
    
    /// Retrieve the next transaction that is associated with an authenticator registration.
    ///
    /// When a `transactionId` is supplied, information relating to that transaction identifier is returned while in a PENDING state.  Otherwise the next transaction is returned.
    /// - Parameters:
    ///   - transactionId: The transaction verification identifier.
    /// - Returns: The ``NextTransactionInfo`` representing the transaction and the number of pending transactions associated with the authenticator.
    func nextTransaction(with transactionId: String?) async throws -> NextTransactionInfo
    
    /// Complete a second factor authentication challenge associated with a registered authenticator for a `PendingTransactionInfo`.
    /// - Parameters:
    ///   - pendingTransaction: The pending transaction to complete.
    ///   - userAction: The enumerated type of user actions that can be performed to complete a transaction.
    ///   - signedData: The base64 encoded value using the private key associated with the factor enrollment.
    func completeTransaction(transaction pendingTransaction: PendingTransactionInfo, action userAction: UserAction, signedData: String) async throws
    
    /// Complete a second factor authentication challenge associated with a registered authenticator for the current `PendingTransactionInfo`.
    /// - Parameters:
    ///   - userAction: The enumerated type of user actions that can be performed to complete a transaction.
    ///   - signedData: The base64 encoded value using the private key associated with the factor enrollment.
    func completeTransaction(action userAction: UserAction, signedData: String) async throws
}

extension MFAServiceDescriptor {
    /// Performs a password-less authentication operation.
    /// - Parameters:
    ///   - loginUri: The endpoint that performs the passwordless login.  The URL is provided as `qrlogin_endpoint` in the response data returned from a QR scan.
    ///   - code: The authorization code provided in the QR scan.
    public func login(using loginUri: URL, code: String) async throws {
        // Safely construct the JSON body
        let payload: [String: String] = ["lsi": code]
        let body = try JSONSerialization.data(withJSONObject: payload, options: [])
        
        // Create the request headers.
        let headers = ["Authorization": "Bearer \(self.accessToken)"]
        let resource = HTTPResource<Void>(.post, url: loginUri, accept: .json, contentType: .json, body: body, headers: headers)
        
        // Perfom the request
        return try await URLSession.shared.dataTask(for: resource)
    }
    
    /// Complete a second factor authentication challenge associated with a registered authenticator.
    /// - Parameters:
    ///   - userAction: The enumerated type of user actions that can be performed to complete a transaction.
    ///   - factor: The enrolled factor associated with transaction.
    ///
    /// ```swift
    /// let controller = MFAServiceController(using: authenticator)
    /// let service =  controller.initiate()
    /// let nextTranaction = try await service.nextTranaction()
    ///
    /// // Get the transaction information and the enrolled factor type to use for signing.
    /// do {
    ///   if let transaction = nextTranaction.current, let factorType = authenticator.enrolledFactors.first(where: { $0.name == transaction.keyName }) {
    ///     try await service.completeTransaction(action .verify, factor: factorType)
    ///   }
    /// }
    /// catch let error {
    ///   print(error)
    /// }
    /// ```
    public func completeTransaction(action userAction: UserAction = .verify, factor: FactorType) async throws {
        guard let pendingTransaction = currentPendingTransaction else {
            throw MFAServiceError.invalidPendingTransaction
        }
        
        try await completeTransaction(transaction: pendingTransaction, action: userAction, factor: factor)
    }
    
    /// Complete a second factor authentication challenge associated with a registered authenticator for a `PendingTransactionInfo`.
    /// - Parameters:
    ///   - transaction: The pending transaction to complete.
    ///   - userAction: The enumerated type of user actions that can be performed to complete a transaction.
    ///   - signedData: The base64 encoded value using the private key associated with the factor enrollment.
    ///
    /// ```swift
    /// let controller = MFAServiceController(using: authenticator)
    /// let service =  controller.initiate()
    /// let nextTranaction = try await service.nextTranaction()
    ///
    /// // Get the transaction information and the enrolled factor type to use for signing.
    /// do {
    ///   if let transaction = nextTranaction.current, let factorType = authenticator.enrolledFactors.first(where: { $0.name == transaction.keyName }) {
    ///     try await service.completeTransaction(nextTransaction, action .verify, factor: factorType)
    ///   }
    /// }
    /// catch let error {
    ///   print(error)
    /// }
    /// ```
    public func completeTransaction(transaction pendingTransaction: PendingTransactionInfo, action userAction: UserAction, factor: FactorType) async throws {
        guard let value = factor.nameAndAlgorithm else {
            throw MFAServiceError.invalidFactor
        }
        
        var signedData = ""
        
        if userAction == .verify {
            // 1. Get the private from the Keychain for the factor.
            let privateKey = try retrievePrivateKey(name: value.name)
            
            // 2. Pass the unwrapped `pendingTransaction.dataToSign` directly to the `sign` function.
            signedData = try sign(pendingTransaction.dataToSign, with: privateKey, signingAlgorithm: value.algorithm)
        }
         
        // 3. Complete the transaction with the signed data.
        try await completeTransaction(transaction: pendingTransaction, action: userAction, signedData: signedData)
    }
}

// MARK: Alias

/// A tuple containing the pending transaction information and a count of the number of transactions still pending.
public typealias NextTransactionInfo = (current: PendingTransactionInfo?, countOfPendingTransactions: Int)

// MARK: Enums

/// The enumerated type of user actions that can be performed to complete a transaction.
public enum UserAction: String {
    /// The user has denied or rejected the transaction.
    case deny = "USER_DENIED"

    /// The user has denied the transaction and marked it as fraudulent.
    case markAsFraud = "USER_FRAUDULENT"

    /// The user is attempting to verify the transaction. The request must also include a value for `signedData`.
    case verify = "VERIFY_ATTEMPT"

    /// The user was unable toverify the transaction due to a failed device biometry attempt.
    case failedBiometry = "BIOMETRY_FAILED"
}

/// A comprehensive enum representing all possible errors that can occur within the Multi-Factor Authentication (MFA) service.
///
/// This custom error type provides specific cases for different failure scenarios, enabling more precise error handling and better debuggability compared to a generic `Error` type.
public enum MFAServiceError: Error, LocalizedError {
    /// An error that occurs when a JSON value fails to decode into the expected type.
    case dataDecodingFailed(reason: String)
    
    /// The factor provided is invalid for signing.
    case invalidFactor
    
    /// Authentication token is missing.
    case tokenNotFound
    
    /// The private key required for a cryptographic operation was not found in the Keychain.
    ///
    /// This is a critical error, as it indicates a failure to retrieve the necessary key for signing data.
    case keyNotFound
    
    /// No pending transaction was available to complete.
    ///
    /// This is a state-related error, indicating that the service was expecting to find an in-progress transaction but could not.
    case invalidPendingTransaction
    
    /// The service was unable to create a new pending transaction to begin a new MFA flow.
    ///
    /// This is an initial state error, typically indicating a problem with the service's readiness.
    case unableToCreateTransaction
    
    /// A general error that occurred perform a MFA operation. The associated value provides the underlying error.
    case underlyingError(error: Error)
    
    public var errorDescription: String? {
        switch self {
        case .dataDecodingFailed(let reason):
            return String(localized: "The received data could not be parsed. \(reason)", bundle: .module)
        case .invalidFactor:
            return String(localized: "Invalid factor to perform signing.", bundle: .module)
        case .tokenNotFound:
            return String(localized: "The access or refresh token is missing.", bundle: .module)
        case .keyNotFound:
            return String(localized: "The private key used for signing was not found.", bundle: .module)
        case .invalidPendingTransaction:
            return String(localized: "No pending transaction was available to complete.", bundle: .module)
        case .unableToCreateTransaction:
            return String(localized: "Unable to create the transaction for identifier.", bundle: .module)
        case .underlyingError(let error):
            return String(localized: "An error occured. \(error.localizedDescription)", bundle: .module)
        }
    }
}

/// An instance you use to instaniate an ``MFAServiceDescriptor`` to perform transaction, login and token refresh operations.
public class MFAServiceController {
    /// The multi-factor authenticator.
    private let authenticator: any MFAAuthenticatorDescriptor
    
    /// Creates the instance with an ``MFAServiceDescriptor``.
    /// - Parameters:
    ///   - authenticator: The multi-factor authenticator.
    public required init(using authenticator: some MFAAuthenticatorDescriptor) {
        precondition(authenticator is OnPremiseAuthenticator || authenticator is CloudAuthenticator)
        self.authenticator = authenticator
    }
    
    /// Determines the service to initiate for a multi-factor authenticator.
    public func initiate() -> MFAServiceDescriptor {
        var certificateTrust: URLSessionDelegate? = nil
        
        // Attempt to create the pinned certificate.
        if let publicKeyCertificate = authenticator.publicKeyCertificate, let pinnedCertificate = PinnedCertificateDelegate(with: publicKeyCertificate) {
            certificateTrust = pinnedCertificate
        }
        
        if let authenticator = authenticator as? OnPremiseAuthenticator {
            // If we created a certificate trust, then ignore the self-signed flag.
            if certificateTrust == nil && authenticator.ignoreSSLCertificate {
                certificateTrust = SelfSignedCertificateDelegate()
            }
            
            return OnPremiseAuthenticatorService(with: self.authenticator.token.accessToken,
                                                 refreshUri: self.authenticator.refreshUri,
                                                 transactionUri: self.authenticator.transactionUri,
                                                 clientId: authenticator.clientId,
                                                 authenticatorId: self.authenticator.id,
                                                 certificateTrust: certificateTrust
            )
        }
        
        return CloudAuthenticatorService(with: self.authenticator.token.accessToken,
                                         refreshUri: self.authenticator.refreshUri,
                                         transactionUri: self.authenticator.transactionUri,
                                         authenticatorId: self.authenticator.id,
                                         certificateTrust: certificateTrust
        )
    }
    
    /// Returns the authentication factor associated with the given transaction.
    ///
    /// Each pending transaction references a specific factor by its `keyName`.  This method resolves that identifier by comparing it against the authenticator’s enrolled factors (such as biometric or user‑presence) and returns the matching `FactorType` if one exists.
    ///
    /// This lookup allows the caller to determine which factor must be used to approve or deny the transaction, without needing to manually inspect each factor type. If no matching factor is found, the method returns `nil`.
    ///
    /// ```swift
    /// if let factor = transactionFactor(for: transaction) {
    ///    // Present UI or perform verification for the matched factor.
    /// }
    /// ```
    ///
    /// - Parameter transaction: The transaction whose associated factor should be resolved.
    /// - Returns: The matching `FactorType` if the authenticator supports it, or `nil` if the transaction references an unknown or unavailable factor.
    public func transactionFactor(for transaction: PendingTransactionInfo) -> FactorType? {
        authenticator.enrolledFactors.first { $0.name == transaction.keyName }
    }
}
