//
// Copyright contributors to the IBM Verify MFA SDK for iOS project
//

import Foundation
import Authentication
import Core

/// A type that indicates when the cloud service fails.
public typealias CloudServiceError = MFAServiceError

/// The `CloudAuthenticatorService` enables authenticators to perform transaction, login and token refresh operations.
public actor CloudAuthenticatorService: MFAServiceDescriptor {
    /// The enumerated type to apply to retrieving cloud transaction data.
    internal enum TransactionFilter: String {
        /// Includes id, creationTime, transactionData and authenticationMethods when the transaction is pending.
        ///
        /// Sorted by creation time.
        case nextPending = "?filter=id,creationTime,transactionData,authenticationMethods&search=state=%22PENDING%22&sort=-creationTime"

        /// Includes id, creationTime, transactionData and authenticationMethods when the transaction pending.
        ///
        /// Search is by id={transactionId}.
        case pendingByIdentifier = "?filter=id,creationTime,transactionData,authenticationMethods&search=state=\u{22}PENDING\u{22}&id=\u{22}%@\u{22}"
    }
    
    public private(set) var accessToken: String
    public private(set) var currentPendingTransaction: PendingTransactionInfo?
    public var publicKeyCertificate: String? = nil
    nonisolated public let refreshUri: URL
    nonisolated public let transactionUri: URL
    
    /// An object that coordinates a group of related, network data transfer tasks.
    private let urlSession: URLSession
    
    /// A unique identifier to link a mobile application to the cloud service.
    private let authenticatorId: String
    
    /// Creates the service with the access token and related endpoint URI's.
    /// - Parameters:
    ///   - accessToken: The access token generated by the authorization server.
    ///   - refreshUri: The location of the endpoint to refresh the OAuth token for the authenticator.
    ///   - transactionUri: The location of the endpoint to perform transaction validation.
    ///   - authenticatorId: An identifier generated during registration to uniquely identify the authenticator.
    ///   - certificateTrust: A delegate to handle session-level certificate pinning.
    public init(with accessToken: String, refreshUri: URL, transactionUri: URL, authenticatorId: String, certificateTrust: URLSessionDelegate? = nil) {
        self.accessToken = accessToken
        self.refreshUri = refreshUri
        self.transactionUri = transactionUri
        self.authenticatorId = authenticatorId
        
        if let certificateTrust = certificateTrust {
            // Set the URLSession for certificate pinning.
            self.urlSession = URLSession(configuration: .default, delegate: certificateTrust, delegateQueue: nil)
        }
        else {
            self.urlSession = URLSession.shared
        }
    }
    
    /// Refresh the OAuth token associated with the registered authenticator.
    ///
    /// The resulting access token is automatically updated in the instance of the `CloudAuthenticatorService` for subsequent operations.
    ///
    /// ```swift
    /// // Using the authenticator properties, create a new CloudAuthenticatorService.
    /// let service = CloudAuthenticatorService(with: authenticator.token.accessToken, refreshUri: authenticator.refreshUri, transactionUri: authenticator.transactionUri)
    ///
    /// // Invoke the refreshToken(autnticator.token.refreshToken) method, optional is the accountName and pushToken.
    /// let result = try await service.refreshToken(using: "abc123")
    /// print(result)
    ///
    /// // Update authenticator token.
    /// authenticator.token = result
    ///
    /// // Encode and save the authenticator to JSON file.
    /// let encoder = JSONEncoder()
    /// encoder.outputFormatting = .prettyPrinted
    /// 
    /// let data = try encoder.encode(authenticator)
    /// print(String(data: data, encoding: .utf8)!)
    /// data.write(to: "authenticator.json")
    /// ```
    ///
    /// - Parameters:
    ///   - refreshToken: The refresh token of the existing authenticator registration.
    ///   - accountName: A list of values added to the initiation request.
    ///   - pushToken: A token that identifies the device to Apple Push Notification Service (APNS).
    ///   - additionalData: (Optional) A collection of options associated with the service.
    /// - Returns: A new `TokenInfo` for the authenticator.
    ///
    /// Communicate with Apple Push Notification service (APNs) and receive a unique device token that identifies your app.  Refer to [Registering Your App with APNs](https://developer.apple.com/documentation/usernotifications/registering_your_app_with_apns).
    public func refreshToken(using refreshToken: String, accountName: String? = nil, pushToken: String? = nil, additionalData: [String: Any]? = nil) async throws -> TokenInfo {
        var attributes = MFAAttributeInfo.dictionary()
        attributes.removeValue(forKey: "applicationName")
        
        attributes["accountName"] = accountName
        attributes["pushToken"] = pushToken
        
        // Merge any additional data provided by the caller.
        if let additionalData {
            attributes.merge(additionalData) { (_, new) in new }
        }
        
        let data: [String: Any] = [
            "refreshToken": refreshToken,
            "attributes": attributes
        ]
        
        // Convert the body dictionary to Data.
        let body: Data
        do {
            body = try JSONSerialization.data(withJSONObject: data)
        }
        catch {
            throw MFAServiceError.dataDecodingFailed(reason: String(localized: "Failed to convert data to UTF-8 string.", bundle: .module))
        }
        
        // Construct and perform the network request.
        let resource = HTTPResource<TokenInfo>(json: .post, url: refreshUri, body: body)
        let result = try await self.urlSession.dataTask(for: resource)
        
        // Update the internal accessToken and return the result.
        self.accessToken = result.accessToken
        
        return result
    }
    
    /// Fetches the next pending transaction, optionally filtered by an identifier.
    ///
    /// - Parameter transactionId: An optional ID to fetch a specific transaction.
    /// - Throws: `MFAServiceError` if the URL cannot be constructed.
    /// - Returns: A `NextTransactionInfo` object with the transaction details.
    ///
    /// When a `transactionId` is supplied, information relating to that transaction identifier is returned while in a PENDING state.  Otherwise the next transaction is returned.
    /// ```swift
    /// // Using the authenticator properties, create a new CloudAuthenticatorService.
    /// let service = CloudAuthenticatorService(with: authenticator.token.accessToken, refreshUri: authenticator.refreshUri, transactionUri: authenticator.transactionUri)
    ///
    /// // Invoke the nextTransaction() method, optional is the transacionID.
    /// let result = try await service.nextTransaction()
    /// print(result)
    /// ```
    public func nextTransaction(with transactionId: String? = nil) async throws -> NextTransactionInfo {
        // The URL for the request.
        let url: URL
        
        // Use a conditional to handle URL construction based on the transactionId.
        if let transactionId = transactionId {
            // Append the transaction ID to the query string for the specified filter.
            let queryString = String(format: TransactionFilter.pendingByIdentifier.rawValue, transactionId)
            
            // Construct the final URL by combining the base URI with the query string.
            guard let finalURL = URL(string: "\(self.transactionUri.absoluteString)\(queryString)") else {
                throw MFAServiceError.dataDecodingFailed(reason: String(localized: "Failed to construct valid URL with transaction ID '\(transactionId)'.", bundle: .module))
            }
            url = finalURL
        }
        else {
            // If no transaction ID is provided, use the next pending filter.
            guard let finalURL = URL(string: "\(self.transactionUri.absoluteString)\(TransactionFilter.nextPending.rawValue)") else {
                throw MFAServiceError.dataDecodingFailed(reason: String(localized: "Failed to construct valid URL for next pending transaction.", bundle: .module))
            }
            url = finalURL
        }
        
        // Create the request headers.
        let headers = ["Authorization": "Bearer \(self.accessToken)"]
        
        // Construct the resource with the final URL.
        let resource = HTTPResource<NextTransactionInfo>(.get, url: url, accept: .json, headers: headers, parse: parsePendingTransaction)
        
        // Perform the request.
        let result = try await self.urlSession.dataTask(for: resource)
        self.currentPendingTransaction = result.current
        
        return result
    }
    
    public func completeTransaction(action userAction: UserAction = .verify, signedData: String) async throws {
        guard let pendingTransaction = currentPendingTransaction else {
            throw MFAServiceError.invalidPendingTransaction
        }
        
        defer {
            // Clear the current pending transaction
            self.currentPendingTransaction = nil
        }
        
        try await completeTransaction(transaction: pendingTransaction, action: userAction, signedData: signedData)
    }
    
    public func completeTransaction(transaction pendingTransaction: PendingTransactionInfo, action userAction: UserAction, signedData: String) async throws {
        
        // Create the request parameters.
        var data: [[String: Any]] = [[:]]
        
        // Only verify operations where we pass the signedData.
        if userAction == .verify {
            data = [["id": pendingTransaction.factorId.lowercased(), "userAction": userAction.rawValue, "signedData": signedData]]
        }
        else {
            data = [["id": pendingTransaction.factorId.lowercased(), "userAction": userAction.rawValue]]
        }
        
        // Covert body dictionary to Data.
        guard let body = try? JSONSerialization.data(withJSONObject: data, options: []) else {
            throw MFAServiceError.dataDecodingFailed(reason: String(localized: "Unable to decode JSON from transaction response.", bundle: .module))
        }
         
        // Create the request headers.
        let headers = ["Authorization": "Bearer \(self.accessToken)"]
        let resource = HTTPResource<Void>(.post, url: pendingTransaction.postbackUri, accept: .json, contentType: .json, body: body, headers: headers)
        
        // Perfom the request.
        return try await self.urlSession.dataTask(for: resource)
    }
}

extension CloudAuthenticatorService {
    // MARK: Internal transaction structures
    
    /// Describes the result of acquiring a pending transction from cloud instances.
    internal struct TransactionResult: Decodable {
        var count: Int = 0
        var verifications: [VerificationInfo]?

        /// The root level JSON structure for decoding.
        private enum CodingKeys: String, CodingKey {
            case total
            case verifications
        }

        struct VerificationInfo: Decodable {
            let id: String
            let creationTime: Date
            let transactionInfo: String
            let methodInfo: [MethodInfo]

            /// The nested root decoding structure based off `CodingKeys`.  Used for cloud transaction data and method parsing.
            private enum CodingKeys: String, CodingKey {
                case id
                case creationTime
                case transactionInfo = "transactionData"
                case methodInfo = "authenticationMethods"
            }
        }

        struct MethodInfo: Decodable {
            let id: String
            let methodType: String
            let subType: String
            let additionalData: [AdditionalDataItem]
            
            var keyName: String? {
                additionalData.first(where: { $0.name == "name" })?.value
            }
            
            struct AdditionalDataItem: Decodable {
                let name: String
                let value: String
            }
        }

        // MARK: Initializers

        /// Creates a new instance by decoding from the given decoder.
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: Decoder) throws {
            // Root keys
            let rootContainer = try decoder.container(keyedBy: CodingKeys.self)
            count = try rootContainer.decode(Int.self, forKey: .total)
            verifications = try rootContainer.decode([VerificationInfo].self, forKey: .verifications)
        }
    }
}

extension CloudAuthenticatorService {
    /// Parse the pending transaction for a cloud authenticator.
    ///
    /// - Parameters:
    ///   - data: The data returned by the server.
    ///   - response: An object that provides response metadata, such as HTTP headers and status code.
    /// - Returns: A value that represents either a success or a failure, including an associated value in each case.
    private func parsePendingTransaction(data: Data?, response: URLResponse?) -> Result<NextTransactionInfo, Error> {
        guard let data = data, !data.isEmpty else {
            return .failure(MFAServiceError.dataDecodingFailed(reason: String(localized: "Unable to decode JSON from transaction response.")))
        }
        
        let decodedResult: TransactionResult
        do {
            let decoder = JSONDecoder()
            decoder.dateDecodingStrategy = .formatted(DateFormatter.iso8061FormatterBehavior)
            decodedResult = try decoder.decode(TransactionResult.self, from: data)
        }
        catch {
            return .failure(MFAServiceError.dataDecodingFailed(reason: error.localizedDescription))
        }

        // Check if there are no pending transactions.
        guard decodedResult.count > 0 else {
            return .success(NextTransactionInfo(current: nil, countOfPendingTransactions: 0))
        }
        
        // Create the pending transaction and return the result.
        if let pendingTransaction = createPendingTransaction(using: decodedResult) {
            return .success(NextTransactionInfo(current: pendingTransaction, countOfPendingTransactions: decodedResult.count))
        }
        
        return .failure(MFAServiceError.dataDecodingFailed(reason: String(localized: "Unable to decode JSON from transaction response.")))
    }
    
    /// Creates a `PendingTransaction` based on the parsed transaction and attribute data.
    ///
    /// - Parameters:
    ///    - result: The `CloudTransactionResult` containing the parsed data.
    /// - Throws: `MFAServiceError` if required data is missing.
    /// - Returns: A `PendingTransactionInfo` object.
    private func createPendingTransaction(using result: TransactionResult) -> PendingTransactionInfo? {
        // 1. Get the first transaction and related method.
        guard let verificationInfo = result.verifications?.first, let methodInfo = verificationInfo.methodInfo.first else {
            return nil
        }

        // 2. Get the postback to the transaction.
        let postbackUri = self.transactionUri.appendingPathComponent(verificationInfo.id)

        // 3. Get the message to display.
        let message = transactionMessage(using: verificationInfo.transactionInfo)
        // 4. Construct the transaction context information into additional data.
        let additionalData = createAdditionalData(using: verificationInfo.transactionInfo)

        // 5. Construct the pending transaction taking data from the transaction, attribute and authentication info.
        let pendingTransactionInfo = PendingTransactionInfo(id: verificationInfo.id,
                                            message: message,
                                            postbackUri: postbackUri,
                                            keyName: methodInfo.keyName ?? "",
                                            factorId: methodInfo.id,
                                            factorType: methodInfo.subType,
                                            dataToSign: verificationInfo.transactionInfo,
                                            timeStamp: verificationInfo.creationTime,
                                            additionalData: additionalData
        )

        return pendingTransactionInfo
    }

    /// Creates a dictionary of available transaction data from the `CloudTransactionResult`.
    /// - Parameters:
    ///   - json: A JSON string representing the transaction data `VerificationInfo`.
    /// - Returns: An array of `TransactionAttribute` and corresponding value.
    private func createAdditionalData(using json: String) -> [TransactionAttribute: String] {
        var result: [TransactionAttribute: String] = [:]

        // Convert the String into Data and serialize to JSON object.
        guard let jsonData = json.data(using: .utf8), var data = try? JSONSerialization.jsonObject(with: jsonData, options: []) as? [String: Any] else {
            return result
        }
        
        // Add the IP address to the result, then remove from dictionary.
        if let ipAddress = data["originIpAddress"] as? String {
            result[.ipAddress] = ipAddress
            data.removeValue(forKey: "originIpAddress")
        }

        // Add the user-agent to the result, then remove from dictionary.
        if let userAgent = data["originUserAgent"] as? String {
            result[.userAgent] = userAgent
            data.removeValue(forKey: "originUserAgent")
        }

        // Add the default type (of request) to the result.  Might be overriden if specified in additionalData.
        result[.type] = String(localized: "Request", bundle: .module)

        // Process the additional data array.
        if let additionalData = data["additionalData"] as? [[String: String]] {
            var customData: [[String: String]] = []
            for item in additionalData {
                guard let name = item["name"], let value = item["value"] else {
                    continue
                }
               
                switch name {
                case "type":
                   result[.type] = value
                case "originLocation":
                    result[.location] = value
                case "imageURL":
                    result[.image] = value
                default:
                    customData.append(item)
                }
           }

            // Assign remaining values to TransactionAttribute.custom.
            if !customData.isEmpty, let customJsonData = try? JSONSerialization.data(withJSONObject: customData) {
                let customJsonString = String(data: customJsonData, encoding: .utf8)
                result[.custom] = customJsonString
            }
        }

        return result
    }

    /// Gets the message associated with the transaction data from the `TransactionResult`.
    /// - Parameters:
    ///   - value: A JSON string representing the transaction data `VerificationInfo`.
    /// - Returns: The transaction message or the default pending transaction message.
    private func transactionMessage(using value: String) -> String {
        guard let jsonData = value.data(using: .utf8), let data = try? JSONSerialization.jsonObject(with: jsonData, options: []) as? [String: Any], let message = data["message"] as? String else {
            return String(localized: "You have a pending request.", bundle: .module)
        }
                
        return message
    }
}
